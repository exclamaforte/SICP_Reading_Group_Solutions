;1.29

(define (simpson f a b n)
    (define h (/ (- b a) n))
    (define (add-term s k)
        (cond ((> k n) s)
              ((or (= k 0) (= k n)) (add-term (+ s (* 1 (f (+ a (* k h))))) (+ k 1)))
              ((odd? k) (add-term (+ s (* 4 (f (+ a (* k h))))) (+ k 1)))
              ((even? k) (add-term (+ s (* 2 (f (+ a (* k h))))) (+ k 1)))))
    (* (/ h 3) (add-term 0 0)))

(define (cube x) (* x x x))

;1.30

(define (sum term a next b)
    (define (iter a result)
        (if (> a b)
            result
            (iter (next a) (+ result (term a)))))
    (iter a 0))
    
;1.31

(define (prod term next a b)
    (define (iter a result)
        (if (> a b)
            result
            (iter (next a) (* result (term a)))))
    (iter a 1))
    
(define pi (* 4 (prod (lambda (x) (/ (* x (+ x 2)) (* (+ x 1) (+ x 1))))
                      (lambda (x) (+ x 2))
                      2
                      10000))) ; pi = 3.141749705738071

;1.32/1.33

;No thanks. I'll just pass you the salt.

;1.34

;(f f) will return (f 2), which will return (2 2), but 2 isn't a function.

;1.35

(define (close-enough? x y) (< (abs (- x y)) 0.001))
(define tolerance 0.00001)
(define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
        (< (abs (- v1 v2))
        tolerance))
    (define (try guess)
        (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1); = 1.6180327868852458

;1.36

(define (fixed-point-d f first-guess)
    (define (close-enough? v1 v2)
        (< (abs (- v1 v2))
        tolerance))
    (define (try guess)
        (display guess)
        (newline)
        (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))
    
(fixed-point-d (lambda (x) (/ (log 1000) (log x))) 2); = 4.555532270803653










